import SecondLesson as x, math

#def motif_enumeration(DNA, k, d):
#    kmers_freq_dict = {}
#    kmers_neigh_freq_dict = {}
#    kmers_neigh_set = set()
#    max_freq_kmer = set()
#    max_freq = 0
#    for DNAstr in DNA:
#        print(DNAstr)
#       for i in range(len(DNAstr) - k):
#            kmer = DNAstr[i:i+k]
#            if kmer not in kmers_freq_dict:
#                kmers_freq_dict[kmer] = 0
#            kmers_freq_dict[kmer] += 1
#    print(kmers_freq_dict)
#   for kmer in kmers_freq_dict:
#       for neighbour in x.neighbours(kmer, d):
#           kmers_neigh_set.add(neighbour)
#   for kmer in kmers_neigh_set:
#       kmers_neigh_freq_dict[kmer] = 0
#       for neighbour in x.neighbours(kmer, d):
#           if neighbour in kmers_freq_dict:
#               kmers_neigh_freq_dict[kmer] += kmers_freq_dict[neighbour]
#   for kmer, kmer_freq in kmers_neigh_freq_dict.items():
#       if kmer_freq > max_freq:
#           max_freq = kmer_freq
#           max_freq_kmer.clear()
#           max_freq_kmer.add(kmer)
#       elif kmer_freq == max_freq:
#          max_freq_kmer.add(kmer)
#   print(kmers_neigh_freq_dict)
#   return max_freq_kmer

def motif_enumeration_(DNA, k, d):
    kmers_freq_dict = {}
    motifs = set()
    kmers_neigh_set = set()
    max_freq_kmer = set()
    max_freq = 0
    for DNAstr in DNA:
        #print(DNAstr)
        for i in range(len(DNAstr) - k + 1):
            kmer = DNAstr[i:i + k]
            if kmer not in kmers_freq_dict:
                kmers_freq_dict[kmer] = 0
            kmers_freq_dict[kmer] += 1
    #print(kmers_freq_dict)
    for kmer in kmers_freq_dict:
        for neighbour in x.neighbours(kmer, d):
            kmers_neigh_set.add(neighbour)
    for kmer in kmers_neigh_set:
        is_motif = True
        for DNAstr in DNA:
            if len(x.findApproxMatchesSlow(kmer, DNAstr, d)) == 0:
                #print(kmer)
                is_motif = False
                break
        if is_motif:
            motifs.add(kmer)
    return motifs


def enthropy(p_matrix):
    enth = 0
    for row in p_matrix:
        for col in row:
            if col == 0:
                enth += 0
            else:
                enth += (col*math.log2(col))
    return -enth
data = [[0.7, 0.6, 1, 1, 0.9, 0.9, 0.9, 0.5, 0.8, 0.7, 0.4, 0.6],[0.2, 0.2, 0, 0, 0.1, 0.1, 0.1, 0.4, 0.1, 0.2, 0.3, 0.4],[0.1, 0.2, 0, 0, 0, 0, 0, 0.1, 0.1, 0.1, 0.3, 0],[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
#print(enthropy(data))

def distance(kmer, DNA):
    dist = len(kmer)
    total_dist = 0
    for DNAstr in DNA:
        for i in range(len(DNAstr)-len(kmer) + 1):
            dist = min(x.hammingDist(kmer, DNAstr[i:i+len(kmer)]), dist)
        total_dist += dist
        dist = len(kmer)
    return total_dist

def distance2(kmer, read):
    dist = len(kmer)
    for i in range(len(read)-len(kmer) + 1):
        dist = min(x.hammingDist(kmer, read[i:i+len(kmer)]), dist)
    return dist

line = "GATTGGTCGTGTTCTTCTGTACACTAGGATATCCCTGGCGACCCCAACGTAACCCCCATCCAGCCGCACACTACCTGCTTTCAGACTGGTTCGGGGTCGGAGTC ACTTCCCCACGCCGGCTCGAGAGTCCTTCGGGACTTAGCAACTGATAACACACCCCGGTGGTCAAATCAGCAAGCGTGTTCAACGATGTGTTTTCAAGTTTAAG CGCAGATACCAGTCCAAGAGCCCACAAACGGCGAGTGTTCCAGCACCCAGGTAATCATGAGACCCCCACAGCGGGGTGTACTAGACATAAAGAACTGGGGCACG ATTGAACATACGTTAACTAGGCCATGGTGTAGCGCGTTACTGTAAATCTAGCACTCTTTACGTTCGTTAGGCGGCAGATAATTTACAATTTCCTGCCGTAGGGG GCGTGAACGTGCGTCCCTTAAGACAAATGCCGGTAGGCTTCCCGTTTCTGATCGCATCAGTTATCGGAACAGGGCCTCACCCGGAAACAAAGTGGTTGAAGCAT CACACGACGGACCCGAAAACGATTCCTTTGTCATCTGCTGTGCTTTAATTCCGGCCGTATCGTCTTTCACCTTCGTGATGACTCCAAATGTACTCTTCTAGAAT CCCGCGCGGTCGTGGGTCCTTCACTGTTAGGCATACGGAAAATCTTTCTACGATTTACGTAAGTAAATTATGAAGGCTTAGTCGACTTCCGCACAATACAGATT ACCAGCTTGATGGTCTCGGAGCCGGGTTGTAGATCCAGGCCTTGGTTGCGCAGATGCTTCAGAAGTTCTCATATAGCTTATCCCCATCCTACCGCTGAAAACGA TTCAAGAATCGATTCGAAGGCAAGGTAGCTATCCAGCTTTCGACCTAATTGGGCAGAGAATCATGACTGCCGAACCGCTTCTAAGCCATGCATGCCGGCGACTC CGCTATGATTGGTACTTTTACGGTTAAAGGCCACTGACCTGATCGCCATCTAATTGCGTCGGTGCAAGCTCCCTCGACACAATGATCTTCCGTACCGATGATAT ACGTCTCATACCCTTGTATTTTACAGGCGGACCGACCAATTCTTCATTTGGCATAAAGATTGCTAACCAGATCCTGCAAGATGACTATGTTATAGCCAGTGCGG GTAATGTCTGTGTGTCAAGACGAAATCTCATAAGTAGATTCTTCGCTGTTGCAATCCTTTCTTCCGCCTGTGCGCTGAGGGACAGTCTGTTCGCGCCCCTAACC GCGTCCATAGAGACGCTGACTGGCCAGTGCCAGCCCCTGCTCTTAATACCCACTCTTTTCCCGCTTCCGATATGAGGTACTACTTAAAGGAAGCGACGGCGCAA TCCTTCCACGAGCGCGGAGAGATATTGTTAACGGCCGGTGTCCTTCAAGAGACGAACCTAAGTGCGGGAGGGAAGGCAAACGACTACGTCAGAGCCGTTACCAT ATTACCATATTGAGCAACAGCCCGTCCAGTAATCGTTACAGGACGTAGCCGATGCTGATTGTCCCTATCAACCACACGCCGCTGTCATAGGGGGAGGGGCAAGT GGCAATGGCTGCCGGCGTTCGGTCGTCTCTAGTGCCATGTCGCGCTTCCCTTGAGTTGTCAGGACGCGTGCGAGCCCACCTGTCGCCAGACCCCAAAACCTATG CGTTTATCGAACAACATGCGGTAGTGAATGCGCAATGGCAGATGCGTATCATGAAGTAAACCAGCCTACAGAATCCTCGACGAATCGGAGCACAGGATCTCGCG TCATGAAACTAGCCGTCCTGGCGACCGGACCGGAAAGATGTACATACGAGACACTTGTCTACAAAGCCCAAGAGGAACGAACGTGCGGATAGGGCGAGACCGGA CAGACCGTCTTGACGGGCACGGTTGCCATTAGCGCTTACGGCGCCCATACTATTCGTACAGCCGCTGCACCGAGTCTTAGTTCTGAGGCCAATTATGAGTGGGC ATCGTCTTGTATGGTTTATCGCTTAAGTTTGAGTTTAGTTTGACGGGTCATACATCTTGCATAAGCACCGACGTTCGAGGGAACCCCATGAGAAACTCTCGTTG TTGCGGAAAATTCTCTGCCGATCAAAAATCTAGTGGTTATAGTAACAACCTACAGTCCAGTTTTTGGAATGCCACGGTCGACATGCGGTCAATGATGCATCTGC ATGGCATAGCGCGGAAGATACGGGATGATTAAGTTACTGAGGCCCGACGAGGTCCTTTTAATACGCCGGTTGAAGTCGAATACAGGTCGTACGCGCCTTGGAAC TCGATGCATACGGGTCTAAACAACCATCGAGAATCTGCCTGAACACCATTGGCAACCGTACGCGTTACTTTAAGCGTAGGCTCCCGCCGGGAGTCTTCTTATCT AATGGTCTAGTTTCTGGCTCGAGTTCACTCAGCTCGGGCGCTTAGGGGGCCAATCAGCGTGACGATGTGTATGCTATATTGGTAGGGTGTACGCTCGGAACATC TGATAGGTCTCATATCATGCACGTCAAACTTTTCATACAAGCGGCTGTTAGGGTATAAGACTGGTAATCCGCGATCTAGTGGACTCGATCCTATAGTAGAACGG GAGTTCATGTCATGCCTACACGACTCGAAAAGGTACCCATACGTTAAGGGCTCTACGGAAATTATAGCAGCGCGAAATTATGTATCTGAGGTGAGGTAAACGCA TTGGTACGATGTGGTGAGCGTATACAGCCGTCGAGGTCGTATAAAGGAGAATTCTTACGGGGCGCCGGGCCGTATGCGTGTGGCGGAGGTAGATTGGGGATGCT ACAATCACCGGACTGTACGCCAGCTCAACGGATATACTAATCGATGGTAACGTAGACACGAGTTCCGCTGTATAAAGCATGGCTTACACTCATTTCGCTTGGAG CACCTAACTAAAACTTATCCCCCTAGAGTACTTAAGAGGCTGGAGGGTCGCTAGCGCATTTTGATAGGTTCTTCTAGGCTCGATGAGATGCCGCTCCGACTTCT AGGTGAGTTGCAATAGATAGGCCGTATATACATTCACACGCTCGACAATCACAGGGCCAAAAGGGAGAGCTCGTCCCCCTTCTAAATGGCCGTACTGGAGTTGG AGTGGTTACATGGATTGTATGCATCATACCCTCGGTCGAGCATAAGCTCAAGTAACATGTGGGCTACTCGCCTCTTTTATGCCAATCCTGAGAGTCATTGAATG TGAATAACAGCCACCCGACGGCAACGTCGAACTTGGATCGATCACTCCGAAACAAACGTAATACACCTCGCGCATGGGAGTATGAGTATCAGCACAGTTCAAGG AGGTAATTGACCCCCTTTAGGACTATTTCGGGTATGGTCTCTGCTTTATTGCCAAAGGATCCGTGTCCGGAAAGTGGTTAGGTTGGCCAACAAAGTAACGAGAA TCTCTACCAGATACCTTCGTTAGGGTCACGACGTCAGAAAATACACTCCGACGGTTGAACCGTCTTCCATACTCGCACAGTTATAATATAAGCATTGGAGGTCA CTTTCCAGCATGAGTCCTCTAAGCTAATACAGTGCTCCTCGTAACGATCGGACTTTGAGGACCAAGATCGTCCGCCGCCGTCCATGCGGTAGGGGACTCTCGAT AGTTCGCCACCTAGAACCGCTCAGCACACGTTTTGGCCTTGTAATCTGTACCGATAAACTGAATCACAGTTCTGAGTAAGAAATTTCCTGGGGGATCGCTCCGG"
DNA = line.split()
#print(DNA)
#print("!!!", distance("ACGACAA", DNA))

def median_string(DNA, k):
    dist = 100000
    med_str = set()
    for kmer in x.neighbours("A"*k, k):
        kmer_dist = distance(kmer, DNA)
        if kmer_dist < dist:
            med_str.clear()
            med_str.add(kmer)
            dist = kmer_dist
        elif kmer_dist == dist:
            med_str.add(kmer)
    return med_str
data = ['GCCTACAGCATGAAGCCACGATTAAAAAGGAAACACGAATTT',
'TGTGGATATGTTCCAGCAGTACTAAGACACGTTATTCCTCTA',
'ACATCAATACACCCCTACCGAATTCGTCTAGCAAAAAATGAC',
'AGAGTTATACACATGCATTGCAGAGTACTCTCTGCCCCAACT',
'GTCCAAAATCGACAAGTAATTAGGAGAACGTATTCGAGACAC',
'ACCAGGACACACCAATCTAGGGATAGAGGGGAGAGAATCCGC',
'TCATTGATACACGTCCTTTCGGCGATGAAAACCTACCTGTAT',
'GGACTGGTGACAGTAAGCTGACGAAAACACCTGACTCTCTTA',
'TTTCGTTATAACATACGTTGGTGTAAACACATATCCCAACTT',
'AACACTAGGCTAAGGTTGAGACACAGCATACCAACTGTGGCG'
]
#print(distance("TCA", data))
#print(median_string(data, 6))

def profile_dist(kmer, profile):
    probability = 1
    profile_dict = {"A": 0, "C": 1, "G": 2, "T": 3}
    for j in range(len(kmer)):
    # print(kmer[j], j)
        probability *= profile[profile_dict[kmer[j]]][j]
    return probability

def consensus_str(profile):
    con_str = ""
    con_chr = ''
    profile_dict = {0: "A", 1: "C", 2: "G", 3: "T"}
    p = 0
    for i in range(len(profile[0])):
        p = 0
        for j in range(4):
            if profile[j][i] > p:
                p = profile[j][i]
                con_chr = profile_dict[j]
        con_str += con_chr
    return con_str
profile = [[1, 1.2, 1.2, 1.7999999999999998, 1, 1, 1, 1], [1.2, 1.5999999999999999, 1.5999999999999999, 1.2, 1.2, 1, 1.2, 1], [1, 1, 1, 1, 1.7999999999999998, 1.9999999999999998, 1.2, 1.9999999999999998], [1.7999999999999998, 1.2, 1.2, 1, 1, 1, 1.5999999999999999, 1]]

print(consensus_str(profile))
def profile_most_probable_kmer(DNA, k, profile):
    profile_dict = {"A": 0, "C": 1, "G": 2, "T": 3}
    kmer_prob_dict = {}
    max_prob_kmer = ""
    max_prob = -1
    #max_prob_kmer = set()
    for i in range(len(DNA) - k + 1):

        kmer = DNA[i:i + k]
        #print(kmer)
        if kmer not in kmer_prob_dict:
            probability = 1
            for j in range(k):
                #print(kmer[j], j)
                probability *= profile[profile_dict[kmer[j]]][j]
            kmer_prob_dict[kmer] = probability
            if probability > max_prob:
                max_prob = probability
                max_prob_kmer = kmer
    #for kmer, kmer_prob in kmer_prob_dict.items():
    #    if kmer_prob > max_prob:
    #        max_prob = kmer_prob
    #        max_prob_kmer.clear()
    #        max_prob_kmer.add(kmer)
    #    elif kmer_prob == max_prob:
    #        max_prob_kmer.add(kmer)
    return max_prob_kmer
profile = [[0.254, 0.296, 0.31, 0.268, 0.31, 0.296, 0.282, 0.183, 0.197, 0.254, 0.197, 0.254, 0.183, 0.197],
[0.338, 0.254, 0.225, 0.183, 0.254, 0.268, 0.169, 0.31, 0.254, 0.268, 0.282, 0.183, 0.268, 0.254],
[0.211, 0.197, 0.296, 0.423, 0.254, 0.169, 0.296, 0.225, 0.31, 0.239, 0.239, 0.282, 0.197, 0.254],
[0.197, 0.254, 0.169, 0.127, 0.183, 0.268, 0.254, 0.282, 0.239, 0.239, 0.282, 0.282, 0.352, 0.296]
]
#print(profile_most_probable_kmer("TGATGCCTAATCCCGGTCGAAGCGGAGCTGAACAATAGT", 14, profile))
if __name__ == "main":
    DNA = ['CGCCAATGTGCGGCGGACGATTAGT',
'GATGAACGTAGGACGCTCCCACTCT',
'GTGCACGCCCAATGTCTCATAAGTG',
'TCAGGGACGAAGGTTACTGAAGATT',
'ACGTATATCTAATTCGAAACGCAGC',
'TCCTTTGTGCCGTCAGTATGAAGTG']
    print("!!!")
    print(*motif_enumeration_greed(DNA, 5, 2))

def make_profile(DNA, k):
    profile = [[0 for i in range(k)] for j in range(4)]
    profile_dict = {"A": 0, "C": 1, "G": 2, "T": 3}
    for DNAstr in DNA:
        for i in range(len(DNAstr)):
            profile[profile_dict[DNAstr[i]]][i] += 1/len(DNA)
    return profile


def make_profile_w_Laplas_rule(DNA, k):  #correct profile
    profile = [[1 for i in range(k)] for j in range(4)]
    profile_dict = {"A": 0, "C": 1, "G": 2, "T": 3}
    for DNAstr in DNA:
        for i in range(len(DNAstr)):
            profile[profile_dict[DNAstr[i]]][i] += 1/len(DNA)
    return profile

def make_profile_w_Laplas_rule2(DNA, k):  #correct profile
    profile = [[1/(len(DNA) * 2) for i in range(k)] for j in range(4)]
    profile_dict = {"A": 0, "C": 1, "G": 2, "T": 3}
    for DNAstr in DNA:
        for i in range(len(DNAstr)):
            profile[profile_dict[DNAstr[i]]][i] += 1/(len(DNA) * 2)
    return profile

#print(make_profile(["AAAA"], 4))

def greedy_motif_search(DNA, k, t):
    best_motifs = []
    motifs = []
    best_enthropy = 100000 #correct this value
    for i in range(len(DNA[0]) - k):
        #print("motifs:", motifs)
        motif = DNA[0][i:i + k]
        motifs.append(motif)
        #print("motifs:", motifs)
        for j in range(1, t):
            profile = make_profile(motifs, k)
            #print(profile_most_probable_kmer(DNA[j], k, profile))
            motifs.append(profile_most_probable_kmer(DNA[j], k, profile))
        #print("motifs:", motifs)
        if enthropy(make_profile(motifs, k)) < best_enthropy:
            best_enthropy = enthropy(make_profile(motifs, k))
            best_motifs = motifs
        motifs = []
    return best_motifs


def greedy_motif_search_w_Laplas_rule(DNA, k, t):
    best_motifs = []
    motifs = []
    best_enthropy = 100000 #correct this value
    for i in range(len(DNA[0]) - k + 1):
        #print("motifs:", motifs)
        motif = DNA[0][i:i + k]
        print("motif:", motif)
        motifs.append(motif)
        #print("motifs:", motifs)
        for j in range(1, t):
            profile = make_profile_w_Laplas_rule(motifs, k)
            #print(profile_most_probable_kmer(DNA[j], k, profile))
            motifs.append(profile_most_probable_kmer(DNA[j], k, profile))
        #print("motifs:", motifs)
        if enthropy(make_profile_w_Laplas_rule(motifs, k)) < best_enthropy:
            best_enthropy = enthropy(make_profile_w_Laplas_rule(motifs, k))
            best_motifs = motifs
        motifs = []
    return best_motifs


#print("!!")
line = '''TTTTCAAGTCTGCCTGTGCGAAGCACACGCACTGAAGATACCGCCTCGACGGGTTAATTTCGTTCATCTGTCCATCAACTCAGAGTAAAAGCGATGAGCCTTTAACACTACAATCCGACTGGATCAGCGAACAGCGAGGGGAAGTCGTGAGTTACA
AGGTCCCTCGTCATCTAAGCGGCGCCTTCGCAGGAAGCGGACCCCTTGCGCTTTAAGGGGGTTGCGCCCGCTGGTTGATCGAACACATGGTCTGAGGGTCTAAGGACGGTCCTAATGTCCGAGGTCATTAGGAGTTCACAATCACTTCCTGAGCCG
ACATGATCTGACCTCTTGCCCTCATCTCGGATCGCTCCAGTCCCGAACGGCCTCGTAAACTTCTCCCTGGGAGCAATGCGAACCTTGATAACTAGATGCGGTAGACACCCGACCCAAACGTCATATACGTCATTTGACAGTTATAGGACGAGCTGC
GAGAGATTACCGTATCACTAGAATCTACGCTGACACAGAATGGCCTTTCTTACCTACTAGTATGTTTAATAGTATCTTGAGTCCCGAATGCTGCCACACGGTGAATCCAATGATCGTACCACAGGGCCTGAGAGATACATTTTGTCTCTCGCACTA
TCGCGGATGCTGCTCTGATAAGTGTATAGCCTGAGGGGAGTCCTGTCATTTGGCGTTCAACGCGTGTCTCGTCACAGGAACTAATTGCGGGAGCGGTAACTTAACGGCGGTATAGTCCAGCATGTCCATTTAAAAATGACAGTCACATGGTCTGAG
GCCACCCCTCTACTATGAGTAATACGGGTGGGACAGCAGGTATCGTCCCTCGAGATAAATTTACTGAGGCCACGGGTTCCTCCGGAGCCTCCACACTAATTGGAAGGTAACGTGAGCCTATAACGCATCGAAACAAGCACTGACTGCGTAACCCAG
ATTGGAAGACGGTCTCCAGGTTAGCTGCGGTATCGTTTGCTTCTACTCTCCCCACTCTGGGTTAACGTCCAGAGCCGGCGAATTTCGGCATGGACGTCGGTTAGGTTAACAGGTACTGATCCAGCTGTCACCACTCATCTACCAGTGGGCGAGTAT
TAATGCGTGTCTCGAAGCGTTCATCATATCTTGCTCCGGCGAAATAGTAGTTGGCCAGGATCTACTAGGGTAACACGCCCTGAATGCGTCGTGTCCAGCGAATTGCGAAATTGCTTGGCCTCTGCATCCTATCACATTCGTGCCCCTTTAAGTCGT
GATACGCGCAGTATGCTGACAATAGATTGGACTAATTGAACCTTCCTGGGGGGCCAAGATTACTCAAGTAGCAATCCAAGTATTGAAACTATAAGTGCGCATGAAACGACAGGAACTGATGGGAAGGATCTGAGTGAGAAACTCTGCCATGGACGG
ATCGCCACTGCTAAGTTCGCCCCTGTTGTGACTGTGGGCAACTTAATTGTGGAAACACCCTTGCTCGCACCGCACAGGGAACGAACTGAATGATGTGGCAGAGCTTAAGTTCAACCTGTTACATGTGCTGACCCTGTCTAATGAGCAAATCTCTCT
TCTCTATGCTTAACGCCCGCTGAGAACGTTCTAGTGGCTCCGGCCAGAGTAGCTCACACTTGGTGTCTCAGTACGAAACTCCTTCGATTCAGTTTGCATAGTAATGTTGCTTATCGTCGAACAAGTACTGACTAAACCCTACGGGGTAATCCATTT
CGGTCCACCAGTACATGCGCTGATCCACGATATGAAACCGTTTGGAGATCACTTACCATATATGTATTTCTTACTTTTGTTGTAGTGTAGCGCCGGCGAAACACGCTGGATAAAGGAAAGGACCCCCTCCCAAACCGCACGGGATCACGCATTATA
TCGGGCACACATTACCAGTCTGACCGGCACTCCTGATCACGTGTATCCAGCCTGCGGATTAGGAGCGCTTCCTAGGAGAGACAAACATGACCTGAATCCAATCGAGTAAAGCGGCACAACAAATTGGCGGCGCGCCCGTCCTCGAGGAAACACGCA
GGCCAGTCGCGATTTTCACCGGAGGAACCGAACGGTACAGGGCCTGAATACAATTAGCAGAGTGTGCCCTACAAGAGGTACTGGGGCACTGGTGAGTTCCGTGGCGCGCGATTTGGCACAATTAAGTTCTCATATCCCAACGCGCATATCGTTGAG
GCTGCGACGGCTAAACTGCAGTCAATTCCGTGGTCCTCATTTTTCAGTACACGTACTGAGATAATGACTACACGGTGGCAGCTTAAGGGCTCCCCGCCTAACTACGAATAAGTACGACGTGCACCGTGTTTATTATGTAGTTGACTTTGAACCGAT
CTACTGCGACTCGAAGTTCCTTAGATCGAGGTGTGCACAAGAACTGATTGTGGAGTGTCACCGGACCACTACAGAGGCCATAGAAAGCGAGGCTGTAAGCCTCAGGAGGCATACTATGAACATCAGGGATCCCACTGGGCAGCCATCGCTTACATT
CCACGCGTCTGGCGGTGCTAGACCACCCCTATAAAATCTGCTGTACCTACCATCTATCGTGGAAATCACTAGCCCCTAGACAGTAGCCAGCACCTGTCCATCAAATAATCAGCGCACTAGACAAGCGCTGATCGTCTAAACTCCCGTTGAGCTCCT
AGTAACAGAGCAGGGCCCGCCTCTTCGCTAGTTCCAGTAGGTTGGGTATTTAACGTCACCCGCTGGAGCAACCTGACGCGTCTGGGACAACCAGATGGCCGGGCGTCCCACATCCTCATGAACGGTCAAAGGACAGGCACTGAGCGGAAGAGTTAA
CTTGAACGCAAACGATCGTGCTAAAGTACAAAGTTTACAGGACCTGAAACACGCTGAAGGCGTCTGACACACTCAGGAGATGACCTAGTTGTATGCTCAACTCATAGGTGAACGGAGAGTCGCTTATCCTTTGGATGGCCCTGACCTTTCCCCGCT
CGTTGCCCCGCTGAACCTGAGTCGGCTCCAGCGCTCACTGGCTAGCCAACACGTCCTGACGTACTGCTTCTATTCTCTCAGCGCTAAGTAGTCTGTTGGATCAGCTAACTATCCGGCCGGGCTCACCAGCAGAGGGTAGACTGCCAATCAAAACAG
CGGTATGGAAAAGTCTACCGGCTTCGGTTGCGCTGCTCGACTTCGGGTTGCAGCGTAAGATGGATGTAGGTAACAGGGACTGAGTCCATGCAAAGAATTTTCAACTCACCAATGAGGGGTCGCGCATAATTACCGGACCCTCATAGTCCTTGATGC
TCCCAACACGCAACAGGGACTGACAAGATGTGGGGCATGAGCCGACATAAGGACATGACCTTTCAGTCCGCAGCGCGATCTAATCGGTGCTGTAGCTCACTGGGCGTAGGCCAAGCCCTTAGCCGCAAGACGAACAACCGGATGGTTGCGATACAA
CCAAATGCGTTACTGATTACAGGTACCGGGCGGCTGATAATATTCTGTTGGTGTCCCTGATAGAACGGGTCAACTTACTGTACTTTGCAACCTGAGCAGTTCGATCCCGTCGAAAGAAAGACCGAAGTCTACTCCTTGGGATTTACAAGAGCTGAG
AAAGCTATCCCACCGAAGGCTGATTTCCATCATCACACACGGCCTGACCCTGCTAGGGGCTCTACCTTGGCAGACGGATTAGAGCACAACTACTCAATTAAGGTATTGTTTCCCGAGGTGACAGGATCCAGGCAGGACCCTGGTACCAGGCTGTTA
GCACTTCCTAACGTTCAGCGCCGATGATTAATCTGCGCTAGTACCAAGGTCTGGATGCTCGTGGAAGTCCTGGCCTACTCTTGGATGCTGTGACTTACACGTACTGAAGACGTTTGTGACGTCTACACTTTTCAGTGAGTACGAGACATTTGACTC'''

DNA = line.split()
#print(DNA)
#for i in greedy_motif_search_w_Laplas_rule(DNA, 12, 25):
#    print(i)
