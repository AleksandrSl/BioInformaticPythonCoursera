def composition(text, k):
    kmers = []
    for i in range(len(text) - k + 1):
        kmers.append(text[i:i+k])
    return sorted(kmers)

#for i in composition("CAGATCCCTATTTACATACTACATTATTACCATCTTCGCGCAAGGAGAACAAGGGCGGAATCACGGACATTAGGGTGCCGGACCCTGCGGTGTTTGCCCCTGTAATATAGAGCCAATAGTGCAGACCTGGAGGGCACTACTAGGTCAGGTAGCTGGCAACCGCTCGTCTCTTGTCAGCGCAGCGAGGTACAGGCTGGGCACCTATACACCTGACGGAAATTCTATTCTAATAGAGATCGCCCATCCAGAACGTAACTCAGCTGCCTCTGCTGTCGCGGACCGTTGCAAGTACATGCGACTGACCTTGAGCATTATTCTATTGAACCGGGGAAAGTCGTAGGGATTGTTAGCTCTTCACGGTCTAGATTGTGTGTATGGGTCCCCGTGGGTATGTAACTCTTCGCGGTTCTTCAGTAATAACATATAGATAGGTAAGTGCAAAGGTTAAGCGTAGTCGTATACGTGTACCATCGTCCAGACCCAGCTGACTGAATGCTAATGTCCGTAATGTACACAAACAACGACTATTTATGGCCGTTTAGACCGGTGATAGTTCTCGCGGACGACAAATTACGCCGCAAACCATCCCAGCGCACTTTCTCAACGATAATTGCCTAATGCTTGCATTTTCACCTCGTACCTGGGGCTCCCTTTAACAACTAGATATGACACTAGGTCATCCACCCCCCCCGTGACTGAAACAAGGCATCAGGCCGACACAATGTTGGGCAGGGAAGGACATCCGAGCATGCATCAGCTGACCTTTGGAAATAACCTAAGTAGTAAAGCGCATGGGGAGCCGGCAAGTTTTAGGAGTAGGGGCGGGCTATATCTGCGACAGAGAGTTAACCGGTGAGTCAATGCTATAGGAGCGCTTTTTCCCATAAGGGGAGTACACTGCTCTGGCGTCCAACTTTCGTTGCGTGGACTTTCCTTTCGAATAAGCTGACAAGCAAGGGGTTGCAGGCCTGCCGGACGTCTAACATCGGCGGGATGTACCGTTGGGGACTCCTCGTACCCAAAAAACGCCCGTGCTATGCCATCGTCGTGAGCGCCTGGCTGGGCAATCGAGTACATCATTATGTGCTGGCGGGCAGCGAAGCGAGAGCTCCACTAATGCTTGTCCTTGTCCCCTGGTTTTCGACTGTCCGTTGTGGAGGAACCCCATCCTAGGGAAGTATACCTCTACAAATGTAACAATTATAGTTAAAATTCAGAGCATTATCATTACGATCCTTCGGTACGACGCCACATTCCCAATGGCTCGGCTCAATTTGCGAGAAAGGCACCTGGCCGGCCGCACAGGGGCGCTGGTTTTTCCGCAGCTTTGTACGCACCCTAACTGGGTTAGCAGTAGAAACGGGACCGGTAACCAAGGTCAGCGTGCACGTCTACTGCATCTTAGGGCTGGGTAGACCAAACCACCGGGAAGTCAATTAAGGAGCCTGCTCTGTCTCGCGACGCAAGGACACCATACCTATTCATATATGCGTGGATTGACGGCTTAAAAGACTACTCCAGCCGTATAGTGGTAGTATGCTCTAGAAATATGTTAACCCCCTACAGGTGTAGTAGCACTAACAACGCAGCAACCTGCTGGGCGCTAAGGTTAAATACTGTTTTGGATGGTTGCCAGCAATGATTCACAACAGGGGACAGGCTTATGAGCATTACCATGAGTGCTAACTACTTAAGCGGATAGCAGGCCAATCAGACAGAGTGTGTGTGTTCCCGATGGATGCATGCCATACGGGCCCTGTATCAGGTCCCCCGTGCGCATACACAGAAAGATAACATCAGCCCAAAAGGGCGCCCATTCTCCGCACTTGGGTACGGACTAGTCGTCCCCCCAGCCCTCGATTAGTGTCAGGCAGGGACCCGGTGGGAGCCTAGCTGGCACGTAGTCCGGCATATAACGTATCAGTGATTGAATCTAGAATTGCTAGTCCTGCAAATCATAGGTTGACGCGAAACCGTCATCAACAAAGAGCACTCATTGTTACTCCACGCCACTGAACCCTGCCCCTTACCATATATGCTGAGCTTCCGGTGAAGACGCGTTACCCAGAAACGCGGCTAAAGCATTTACGGCAAGCAACATACGTGTCACCAGGACGCATAAGAGCGACGAGTCACTTTACGGGAAAGCTGTTAAAGTCACGTTTTAAGGACACTCTATGCGCCGTATCGCGGCGCTGCGTATGTGGCCTAGAGTAGCAAGTTTGAACAATCGTTATCGCCTCGTAACTCCGTTTTTCCTCCTTACACGATGCCTATTTACTGGACTAGGGCACCGTTGGTGCGACGAGGCAGGAATTAATCGAAAGCCCTTTGCTGGCGTGAGCGATAAATACCGTAGAGTTGAGTAAACCTAAGATGTTGTGCAGCACCTGACGGGGGTAAAATCAACCCGATTGCTACGTAGATTCACAATTTTTTAACGCAAGAGCTTTGGGGAGATACCAATGGTGGCTCCGGCAGGCATCGCCGGCTGGTGTCTCAACGTTTTGGCCGCGGAATATCCGTGAGGGCAGCACTCTCGATGACAAATCACCAATAGAGCGTATAGTGAAGTGCCTCTCAATCGACGTTCGAATCATTACGCTGTCAGGATTCAATGGTCAGAATCGGGGATGAGACCATCTTAGTCGGTGAAGGAGAGATGTTACGTATGGGGATGTTTAGCCGCGTTCATTTTTAGTGGTATTAGCACCCGAGAGTCGCCCCGCAAGGAGGTAAACCGAGCATACTTTTAGGGCTCGTACGCGTATGGCATAAAGGCTGTCACATCATCCCGCACATAAAACTGGCTCCAGTTCCATATCCTGGTCACACTCAGCCCCGAACCGACGGAGAATACAACCTTGGAAGGCTGAAGTCATTTGTCGAAGTTCCATTCTTTCGCTCCGAGAACAACCGTTTGCAGGGCGCAAGCGCAACGGTGACACTCCCGTATAGAAGGCTCACGAAAAAGCGTTATGGCTGTAGGTGGAGATAGTCTCCTTTAAAGGGCATGGGCGCGGTAGGCGCAGTTTGTCCGAAGAGGTCGGCCTGTATATCACAACATATAAGCAGTACCTATTCAGTCAAACGTAAAACTCGTATCACGCCGCGTCTCCTTTACTGAAAACAGGCACTACCACTCGTCTCTATAGGCGTCTCTTATTTGTCGTTCTCTAGTTTGACCTAGGCAATCTAAAGATGAAGTCCTTTTCGGATCATAAGCATCGTAAAGGATGGTAAACAAAGCAATAATTTAATAAGTTCAAAGCGACGATTGACATTTACTCCGGAGTAAGGTAGACCCTGCGTACGTTTTGTTTATCTTTCGATCATCCCTTGCAGCGAAACTGGTCTAGTGACGCGGACCGGGCCTCTTGGGCGTGCAAGGTTCCCTAAATAAAATTATTAATTCACATCCCCGCATTATATGTCTCAAATACCGTATCGAGGCGGAGCCAGTCCATACTTGACCATATAGTTAGATCTTTTGGTTGAAACAGGTTTTATGTCTGCCGGATTCAGCAAACGCAACGCAAAATAGCGCGATCATATAAGCGGCATTGCTTGGAAAGCTCCTCCCTTACGCCGGCCTCGGAGGCCCATCACACCTAGATGTCACTATCGCGCGTTTAAAGTGCGCGTTACTCTATCTGATAATTAGACGTATGCACTATAGCTTAATACCCTCCTGGCACCATCGATCTGCGGCATCTATCACTGCGGGGCAATCGCCGCCAATTTTGGCAAGTACTGTAGCCGACAGATCTCCGGCAATGACGCGCGTGGATGTTACGCGCCGGTCGCTATAAGCAGACGTGGCCTTCCGATCCCTTATCTACGCCCCGCCATCCCGGTAATATGTAGGTGTGCTGGTGTCTGCGTAATTATACGGATACCAGTAGTACGGCCACTGCCGGTCTGTAGGCGTGCACCCTCTCAGCCGGCTCATGATGCGTCCTTAACACCCACAACGTCCGACGGAGTGCAGCGGCATGGACTAGGAGGTGCTTGCCACTATGTGAAGATGTATTAGGTCATCTACCCACTTTGGCGCCGTAGATAAACTTTGCTAGAGCCGTTCTCCCCCGACTTCAATCTGCGGCGCACCTAACTCCTACCCGACCAGACTTACCCAATCATCACACCTACTACTGACAGGAAACGTGGCTAAAGGAAACCTGTCCCTGCCATATTAGTATGTCGATTAAGTGCAATCTACCGCTGATATTGTGTATTGGTAGAGGTGGGAATTTACATTAGTTGATATAGACCCCTTCGGGCGTACTTTATATAGGGGATTCGTGATGCGTCTTAGGGAAAGGGCGAAAGGGGCGGTTGAAGGGCTGTCGTAACGTAGTGCTAGAGCTTGGGCCTCGCGAGGCCACGCATCGTGTCTCGGCACCTTCTGCAATGATAGGGAGGTCAGAATTCATGACGATGTCCAATCAGACCACCTCGAACCTATTCCGGCCGCGGCCACTTCATGCTCCTCGTTGTTATTCACCACATCGCGAAGAGGTAGCACACGTAGACCTTGAAACCAAGTGGTATCAGGAACTGGAGTGCTTATATGCTTGTAGGAAGTAGGCTGCTACTCCCAACATTCACGATCTCTCTCCGGTTACTCGGCAAAGCGTTCTTGTTGACAAGTTCTTTTTAGAGTTTACTTGCTTTACGTTGAGTGTTCTAGAACCCATCTATGTCCATCAATCAGAGCACACCGGCTGTCTCACCATTTGTTAACTAAAGGGTCGATCCAGTGCTGTGGATAGGATTACATACGACTATCTCAGCCTCTCTTCCTTAATCATGTCCAACTACTAGCTTGGACTCGAATCTAGTATGTAATCTTGGAAGAAGGTGACCCGCTGGGCGTCGAGGGTGCCATACTTCTTTGCACAATTAGCCTTGAGAGTCGCCTATCCCACAGTACGAGCCGTACCCGCGAACGGCGTAGCCTCTTCTCTTGACACAACTTGTCAAGCGAAACAACGTGA", 100):
#    print(i)

def str_from_path(path):
    res = path[0]
    for i in path[1:]:
        res += i[-1]
    return res
path = "".split()
#print(str_from_path(path))

def make_overlap_graph(reads):
    suffix_dict = {}
    preffix_dict = {}
    overlap_dict = {}
    for read in reads:
        pref = read[:-1]
        suf = read[1:]
        if suf not in suffix_dict:
            suffix_dict[suf] = []
        if pref not in preffix_dict:
            preffix_dict[pref] = []
        suffix_dict[suf].append(read)
        preffix_dict[pref].append(read)
    print(suffix_dict, "/n", preffix_dict)
    for suf in suffix_dict:
        if suf in preffix_dict:
            for read in suffix_dict[suf]:
                overlap_dict[read] = preffix_dict[suf]
    return overlap_dict


reads = "".split()

#for key, val in make_overlap_graph(reads).items():
#    if len(val) > 1:
#        for v in val:
#            print(key, "->", v)
#    else:
#        print(key, "->", *val)

def de_bruijn_graph(k,text):
    suffix_dict = {}
    graph = {}
    last_pref = None
    for i in range(len(text) - k + 1):
        kmer = text[i:i + k]
        suf = kmer[1:]
        pref = kmer[:-1]
        if pref not in graph:
            graph[pref] = {'lnode':[], 'rnode':[], 'weights':[]}
        if last_pref is not None:
            graph[pref]['lnode'].append(last_pref)
        graph[pref]['rnode'].append(suf)
        graph[pref]['weights'].append(kmer)
        last_pref = pref
    return graph

def de_bruijn_graph2(reads):
    graph = {}
    for read in reads:
        suf = read[1:]
        pref = read[:-1]
        if suf not in graph:
            graph[suf] = {'in':[], 'out':[], 'weights':[]}
        if pref not in graph:
            graph[pref] = {'in':[], 'out':[], 'weights':[]}
        graph[pref]['out'].append(suf)
        graph[suf]['in'].append(pref)
        graph[pref]['weights'].append(read)
    return graph




#graph = de_bruijn_graph(12, "CGGATCTTCAAGGGTTTTCAGAGTCTTAGCTTGATCGTCCGTGGACGGACCTTGGACGGTACTTCATATTATATATGGCGGTTAATGGGAAAAATGCTTATTGTCTCTTACGTGCGGGATTCTGCAAGAGGATCCAACGCGGCGCTAAGACAGTCGAGCGCTTACTGCTTCTGTCGGCTATCGTATCTGAGGCGACAGCTAGTTAATATACCGTGGGACTCAGCTCGTGGTAAGGTTCATTTGATATTCAGGCGGCGATAACCGCTAGGACGACCTTAGGCGACGGACAGAACTAACCACGCCTGTACCGCTTGCGTAGCATGAAGTAAACGTCGCATATATAGCGCGTAAGATAGGTAGCAGGATGTACTGCAGCGGAGGATATCTTGCCGCACAAACCGTTGATGGCTCCACGCACAAAAGAGATAAACCATTAAAGAATTACGCTACAGCATCAGCACCGCTTTTTCCAATTAGAGACTCCCATACATGATCCAGATTCCTCGACAGTTACATCTTATAAAGCCAATTTGTTGGGCGTGTCTTCACGTTTTGCCCAGTCGAGGAGTTGAGTAGCTGTAATCGTTTTGTCCACCTCTCGCGAACGGCGGTAGTAGAATAATTCGTATTTTCTATTAATCGCGATTACGCCGCACAATAATGCACATGTGCGCCTCAAGCGATCAGAAGGGCTCGTTACACTTACTCCTTCAATCCTTTAGGGTGACCTTTTCGTAGCCTACCCGAAGACGTGCTAAAGAAACCAAGGTACCAGGTGTTCTCCGGCGATAAATCACGTTAACGGAAGTTCAGATGAGCTTTCCAGTCTAACTCGACACGTGATCGCTAAGGAGTGTAGAAACGAAAAATGAGCAGCCGTATGCTGGGCGTTGCCAACATAGTCTATTGTCAGACTGGATGGACGCGTTTGGTCCCCAAACAAGTGAGACTGATTATTGGTGCTTATTGCCCACGAATCACCGTGATGGGCAGCGCTTAGAACCTCATATCCTAGTGTATTGTCCATAGGGATTATTATCTCAATCAGCGGTCAGGTACCAACAGATGCCAACGTTATTGTTTTCACTCCCGAACACAAGATCACTCATTATGGGACGGAACCAGTCTGCATTTCAGTAGAGCATTCTGCACGCTCAACATAATAGAAACGTTACAAACGGAGGGCTGTGACGGGCAGCGCCGGAAACTAACTGCGACAGAGCAAATTGTACTAATAAGCAACTCGGTTATCCGGGGAAGAACGTGGTGGTGGTCGCTTTAGACCGAGTAGCCACTTCAGCAAATGGTATTGCAAAAGTGTAATGGACTCGCCCGACTTTGGCATCAGAGTTTGCATAAGACTATGTAGAATCTAACTCGACACTGGTTAATTATATTTTAGTGAGATTATGCTTCTCAACCGGATAACGGCTTCCATATTCTTCTATGTTACAAGAATCGGGTGGGGAATGGGTCTATTGGAACAGTCACACCCCCCAACTGGCCCACCCCTTCAGTGGGCGTGTCGCTAAGGGCGACAGACATTACATAACAAGCTGGGCCACTTATTCATCCAGGAGGTTAGCTTTAGCTGAGGAAGCGGTTGTTCGCTTCGTACTCAGAGACGGCTAGCGTCAGTCCACACTGTGACCATTACAAGCCAACTGATATACGCTGCCCTTTGAACTAGAGGGTGAGCCTCACACGCAATTTAAGGTACGGATCATCCTACCCCATATTATGATCTGTCCCCTGACGGCTTATGTGTAAGGTGATCGGGTGTGTGATTCTTAATCAGGCAGGACCCGACCACGTATGCATATCCTGACTGCAGGAATTGCCAGCGTCGGCATGGCAGTGTCGGGGAAAAAGGTACCTCGAATGCCAGCAGGGAGGCGTAACGGCCAAAAGTCTTCGTTCAGTTCTCGGGATTTCTCGAGAGAACGTAGCATAAGGTGAGATTGACTCGAGAAGCTTCCTGAAGGGGATTGGCAGCTCGC")
reads = '''GCGA CAAG
AAGA
GCCG
ACAA
AGTA
TAGG
AGTA
ACGT
AGCC
TTCG
AGTT
AGTA
CGTA
GCGC
GCGA
GGTC
GCAT
AAGC
TAGA
ACAG
TAGA
TCCT
CCCC
GCGC
ATCC
AGTA
AAGA
GCGA
CGTA'''.split()
graph = de_bruijn_graph2(reads)
##for node in graph:
#    if len(graph[node]["rnode"]) > 1:
#        print(node, "->", ", ".join(graph[node]["rnode"]).lstrip(", "))
#        #for n in graph[node]["rnode"]:
#        #    print(n, ",", end="")
#    elif len(graph[node]["rnode"]) == 0:
#        continue
#    else:
#        print(node, "->", *graph[node]["rnode"])


def de_bruijn(k, n):
    """
    De Bruijn sequence for alphabet k
    and subsequences of length n.
    """
    try:
        # let's see if k can be cast to an integer;
        # if so, make our alphabet a list
        _ = int(k)
        alphabet = list(map(str, range(k)))

    except (ValueError, TypeError):
        alphabet = k
        k = len(k)

    a = [0] * k * n
    sequence = []

    def db(t, p):
        if t > n:
            if n % p == 0:
                sequence.extend(a[1:p + 1])
        else:
            a[t] = a[t - p]
            db(t + 1, p)
            for j in range(a[t - p] + 1, k):
                a[t] = j
                db(t + 1, t)
    db(1, 1)
    return "".join(alphabet[i] for i in sequence)

print(de_bruijn(2, 3))
print(de_bruijn("abcd", 2))

a = "0111010001"
for i in range(len(a) - 3 + 1):
    print (a[i:i+3])